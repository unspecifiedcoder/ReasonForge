[
  {
    "task_id": "code-algo-001",
    "problem": "Implement a function that finds the longest increasing subsequence (LIS) in an array of integers. Return the length of the LIS. Your solution must run in O(n log n) time.",
    "domain": "code",
    "difficulty": 5,
    "timeout_seconds": 300,
    "ground_truth": "Use patience sorting / binary search approach. Maintain a list 'tails' where tails[i] is the smallest tail element of all increasing subsequences of length i+1. For each element, binary search for the position to replace in tails (or append if larger than all). The length of tails is the LIS length. Example: [10,9,2,5,3,7,101,18] → LIS length = 4.",
    "ground_truth_score": 1.0,
    "is_trap": false,
    "previously_unsolved": false,
    "tags": ["dynamic-programming", "binary-search", "subsequence"],
    "source": "benchmark",
    "author": "ReasonForge Team",
    "created_at": "2026-01-15"
  },
  {
    "task_id": "code-algo-002",
    "problem": "Given a directed graph with possibly negative edge weights but no negative cycles, find the shortest path from a source vertex to all other vertices. The graph has V vertices and E edges. Describe the algorithm and its time complexity.",
    "domain": "code",
    "difficulty": 4,
    "timeout_seconds": 240,
    "ground_truth": "Use the Bellman-Ford algorithm. Initialize dist[source] = 0, dist[v] = ∞ for all others. Repeat V-1 times: for each edge (u,v,w), if dist[u] + w < dist[v], update dist[v] = dist[u] + w. Time complexity: O(V·E). An additional pass can detect negative cycles (if any distance is updated in the V-th iteration).",
    "ground_truth_score": 1.0,
    "is_trap": false,
    "previously_unsolved": false,
    "tags": ["graph", "shortest-path", "bellman-ford"],
    "source": "benchmark",
    "author": "ReasonForge Team",
    "created_at": "2026-01-15"
  },
  {
    "task_id": "code-algo-003",
    "problem": "You need to sort a list of 1 million 32-bit integers. A junior developer suggests using quicksort because it is always O(n log n). Is this reasoning correct? What would you recommend?",
    "domain": "code",
    "difficulty": 3,
    "timeout_seconds": 180,
    "ground_truth": "The reasoning is INCORRECT. Quicksort's worst case is O(n²), not O(n log n). The average case is O(n log n) with good pivot selection. For practical use, recommend: (1) Quicksort with randomized pivot or median-of-three to avoid worst case, (2) Introsort (quicksort that falls back to heapsort at recursion depth limit), which guarantees O(n log n), or (3) For 32-bit integers specifically, radix sort achieves O(n) time. Most standard library sorts use introsort or Timsort.",
    "ground_truth_score": 0.0,
    "is_trap": true,
    "previously_unsolved": false,
    "tags": ["trap", "sorting", "complexity-analysis", "common-misconception"],
    "source": "benchmark",
    "author": "ReasonForge Team",
    "created_at": "2026-01-15"
  },
  {
    "task_id": "code-algo-004",
    "problem": "Design a data structure that supports the following operations in O(1) amortized time: insert(val), remove(val), getRandom() — which returns a random element uniformly at random.",
    "domain": "code",
    "difficulty": 5,
    "timeout_seconds": 300,
    "ground_truth": "Use a combination of a dynamic array (list) and a hash map. The hash map maps values to their indices in the array. insert(val): append to array, store index in map. O(1). remove(val): swap the element with the last element in the array, update the map for the swapped element, then pop the last element and remove from map. O(1). getRandom(): generate random index in [0, len-1] and return array[index]. O(1).",
    "ground_truth_score": 1.0,
    "is_trap": false,
    "previously_unsolved": false,
    "tags": ["data-structure", "hash-map", "randomization", "design"],
    "source": "benchmark",
    "author": "ReasonForge Team",
    "created_at": "2026-01-15"
  },
  {
    "task_id": "code-algo-005",
    "problem": "Implement an algorithm to find all articulation points (cut vertices) in an undirected connected graph with V vertices and E edges. The algorithm should run in O(V + E) time.",
    "domain": "code",
    "difficulty": 7,
    "timeout_seconds": 360,
    "ground_truth": "Use Tarjan's algorithm with DFS. Maintain discovery time disc[u] and the lowest discovery time reachable low[u]. A vertex u is an articulation point if: (1) u is the root of the DFS tree and has 2+ children, OR (2) u is not root and has a child v where low[v] >= disc[u] (meaning no back edge from subtree of v reaches an ancestor of u). Time: O(V + E) since it's a single DFS pass.",
    "ground_truth_score": 1.0,
    "is_trap": false,
    "previously_unsolved": false,
    "tags": ["graph", "DFS", "tarjan", "articulation-points"],
    "source": "benchmark",
    "author": "ReasonForge Team",
    "created_at": "2026-01-15"
  },
  {
    "task_id": "code-algo-006",
    "problem": "Given an array of n integers, find a contiguous subarray whose sum is closest to zero. Your solution should be more efficient than O(n²).",
    "domain": "code",
    "difficulty": 6,
    "timeout_seconds": 300,
    "ground_truth": "Compute prefix sums P[0..n] where P[0]=0 and P[i] = A[0]+...+A[i-1]. The sum of subarray A[i..j-1] = P[j] - P[i]. To minimize |P[j] - P[i]|, sort the prefix sums (keeping original indices) and check adjacent pairs in sorted order. The minimum difference among adjacent sorted prefix sums gives the answer. Time: O(n log n) for sorting.",
    "ground_truth_score": 1.0,
    "is_trap": false,
    "previously_unsolved": false,
    "tags": ["prefix-sum", "sorting", "subarray"],
    "source": "benchmark",
    "author": "ReasonForge Team",
    "created_at": "2026-01-15"
  },
  {
    "task_id": "code-algo-007",
    "problem": "A developer claims that using a hash table guarantees O(1) lookup time for any input. They propose replacing all binary search tree operations in a codebase with hash table operations to improve performance universally. Evaluate this claim.",
    "domain": "code",
    "difficulty": 4,
    "timeout_seconds": 240,
    "ground_truth": "This claim is MISLEADING. Hash table O(1) is the average/amortized case with a good hash function. Worst case is O(n) due to collisions. BSTs provide O(log n) worst case (if balanced) and support ordered operations (range queries, in-order traversal, finding min/max, predecessor/successor) that hash tables cannot do efficiently. The replacement is inappropriate when: (1) ordered operations are needed, (2) worst-case guarantees matter, (3) adversarial inputs are possible (hash DoS), (4) memory locality matters (BSTs can be cache-friendlier for certain access patterns).",
    "ground_truth_score": 0.0,
    "is_trap": true,
    "previously_unsolved": false,
    "tags": ["trap", "hash-table", "BST", "complexity", "trade-offs"],
    "source": "benchmark",
    "author": "ReasonForge Team",
    "created_at": "2026-01-15"
  },
  {
    "task_id": "code-algo-008",
    "problem": "Implement a solution for the 0/1 knapsack problem: given n items with weights w[i] and values v[i], and a knapsack capacity W, find the maximum total value that can be carried. Items cannot be fractioned.",
    "domain": "code",
    "difficulty": 5,
    "timeout_seconds": 300,
    "ground_truth": "Use dynamic programming. Define dp[i][j] = max value using items 1..i with capacity j. dp[0][j] = 0. For each item i: dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]] + v[i]) if j >= w[i], else dp[i-1][j]. Answer: dp[n][W]. Space optimization: use 1D array, iterate j from W down to w[i]. Time: O(nW), Space: O(W).",
    "ground_truth_score": 1.0,
    "is_trap": false,
    "previously_unsolved": false,
    "tags": ["dynamic-programming", "knapsack", "optimization"],
    "source": "benchmark",
    "author": "ReasonForge Team",
    "created_at": "2026-01-15"
  },
  {
    "task_id": "code-algo-009",
    "problem": "Given a string of length n, find the longest palindromic substring in O(n) time.",
    "domain": "code",
    "difficulty": 8,
    "timeout_seconds": 420,
    "ground_truth": "Use Manacher's algorithm. Transform string by inserting special characters (e.g., '#') between each character and at boundaries. Maintain a center C and right boundary R of the rightmost palindrome found so far. For each position i, use the mirror property: p[i] = min(R-i, p[2C-i]) if i < R, else p[i] = 0. Then try to expand around i. Update C, R when i + p[i] > R. The array p gives palindrome radii. Time: O(n) amortized since R only increases.",
    "ground_truth_score": 1.0,
    "is_trap": false,
    "previously_unsolved": false,
    "tags": ["string", "palindrome", "manacher", "linear-time"],
    "source": "benchmark",
    "author": "ReasonForge Team",
    "created_at": "2026-01-15"
  },
  {
    "task_id": "code-algo-010",
    "problem": "Implement a concurrent lock-free queue that supports enqueue and dequeue operations from multiple threads without using mutexes. Describe the algorithm and discuss the ABA problem.",
    "domain": "code",
    "difficulty": 9,
    "timeout_seconds": 480,
    "ground_truth": "Use the Michael-Scott lock-free queue. Maintain Head and Tail pointers to sentinel/dummy nodes. Enqueue: create new node, CAS Tail->next from NULL to new node, then CAS Tail to new node. Dequeue: read Head->next, if non-null CAS Head to Head->next and return value. The ABA problem occurs when a CAS succeeds even though the value changed from A→B→A between read and CAS. Solve with tagged pointers (version counters) or hazard pointers for safe memory reclamation. Use atomic compare-and-swap (CAS) as the fundamental primitive.",
    "ground_truth_score": 1.0,
    "is_trap": false,
    "previously_unsolved": false,
    "tags": ["concurrency", "lock-free", "queue", "CAS", "ABA-problem"],
    "source": "benchmark",
    "author": "ReasonForge Team",
    "created_at": "2026-01-15"
  }
]
